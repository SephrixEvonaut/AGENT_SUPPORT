// ============================================================================
// SEQUENCE EXECUTOR - Sends keypresses with human-like timing
// ============================================================================
//
// FEATURES:
// - Multiple concurrent sequences (different bindings run in parallel)
// - Per-binding execution tracking (same binding won't overlap)
// - Human-like timing with sophisticated multi-layer randomization
// - Non-blocking async execution
// - Discord volume/mic control integration
// - TTS timer system
//
// RANDOMIZATION SYSTEM:
// Uses HumanRandomizer for all timing values which provides:
// - Hash-based pseudo-randomness (appears random, deterministic)
// - Gaussian bias toward "sweet spot" values humans naturally produce
// - History-based "correction" that reinforces natural distributions
// - Multi-layer obfuscation that resists statistical detection
//
// ============================================================================

import robot from "robotjs";
import {
  SequenceStep,
  MacroBinding,
  SEQUENCE_CONSTRAINTS,
  CompiledProfile,
} from "./types.js";
import { isConundrumKey } from "./profileCompiler.js";
import { TrafficController } from "./trafficController.js";
import { TimerManager } from "./timerManager.js";
import { getDiscordController } from "./discordController.js";
import { logger } from "./logger.js";
import {
  getHumanBufferDelay,
  getHumanKeyDownDuration,
  getHumanEchoHitDuration,
  getHumanReleaseDelay,
  getHumanDualKeyOffset,
  getHumanDelay,
} from "./humanRandomizer.js";

export interface ExecutionEvent {
  type: "started" | "step" | "completed" | "error" | "cancelled";
  bindingName: string;
  step?: SequenceStep;
  stepIndex?: number;
  delay?: number;
  error?: string;
  timestamp: number;
}

export type ExecutionCallback = (event: ExecutionEvent) => void;

export class SequenceExecutor {
  // Per-binding execution state - allows DIFFERENT bindings to run concurrently
  // but prevents the SAME binding from overlapping with itself
  private isExecuting: Map<string, boolean> = new Map();

  // Track all active executions for monitoring
  private activeExecutions: Set<string> = new Set();

  // Global shutdown flag - stops all async operations immediately
  private isShutdown: boolean = false;

  private callback: ExecutionCallback;
  private compiledProfile: CompiledProfile | null = null;
  private trafficController: TrafficController | null = null;
  private timerManager: TimerManager;

  // Abort controllers for cancellable sleeps
  private sleepAbortController: AbortController | null = null;

  // Track held modifiers from holdThroughNext steps
  private heldModifier: {
    key: string;
    modifiers: string[];
    releaseDelayMin: number;
    releaseDelayMax: number;
  } | null = null;

  constructor(callback?: ExecutionCallback, compiledProfile?: CompiledProfile) {
    this.callback = callback || (() => {});
    if (compiledProfile) this.setCompiledProfile(compiledProfile);
    this.timerManager = new TimerManager();

    // Configure robotjs for minimal internal delay
    robot.setKeyboardDelay(1);

    logger.debug("SequenceExecutor initialized");
    logger.debug(
      "Concurrent sequences: ENABLED (different bindings run in parallel)"
    );
    logger.debug("Per-binding overlap: PREVENTED (same binding won't stack)");
    logger.debug("Randomization: HUMAN-LIKE (multi-layer obfuscation)");
  }

  /**
   * Provide a compiled profile to enable traffic control.
   */
  setCompiledProfile(compiled: CompiledProfile): void {
    this.compiledProfile = compiled;
    this.trafficController = new TrafficController(compiled);
  }

  /**
   * Validate a sequence step meets timing constraints
   */
  private validateStep(step: SequenceStep, stepIndex: number): string | null {
    // Scroll steps have simpler validation
    if (step.scrollDirection) {
      if (!["up", "down"].includes(step.scrollDirection)) {
        return `Step ${stepIndex}: scrollDirection must be "up" or "down"`;
      }
      return null;
    }

    // If bufferTier is provided, we use tiered buffer delays and skip legacy min/max validation
    if (step.bufferTier) {
      if (!["low", "medium", "high"].includes(step.bufferTier)) {
        return `Step ${stepIndex} ("${step.key}"): bufferTier must be one of low|medium|high`;
      }
    } else {
      if (step.minDelay < SEQUENCE_CONSTRAINTS.MIN_DELAY) {
        return `Step ${stepIndex} ("${step.key}"): minDelay must be >= ${SEQUENCE_CONSTRAINTS.MIN_DELAY}ms (got ${step.minDelay}ms)`;
      }

      const variance = step.maxDelay - step.minDelay;
      if (variance < SEQUENCE_CONSTRAINTS.MIN_VARIANCE) {
        return `Step ${stepIndex} ("${step.key}"): variance (max - min) must be >= ${SEQUENCE_CONSTRAINTS.MIN_VARIANCE}ms (got ${variance}ms)`;
      }
    }

    // Validate keyDownDuration if provided
    if (step.keyDownDuration) {
      const [kmin, kmax] = step.keyDownDuration;
      if (kmin <= 0 || kmax < kmin) {
        return `Step ${stepIndex} ("${step.key}"): keyDownDuration must be [min,max] with min>0 and max>=min`;
      }
    }

    return null;
  }

  /**
   * Validate entire sequence meets constraints
   */
  private validateSequence(sequence: SequenceStep[]): string | null {
    for (let i = 0; i < sequence.length; i++) {
      const step = sequence[i];
      const error = this.validateStep(step, i);
      if (error) return error;
    }

    const keyStepCount: Map<string, number> = new Map();
    for (const step of sequence) {
      // Skip scroll steps which don't have a key
      if (step.scrollDirection) continue;

      const normalizedKey = step.key.toLowerCase();
      const count = keyStepCount.get(normalizedKey) || 0;
      keyStepCount.set(normalizedKey, count + 1);
    }

    if (keyStepCount.size > SEQUENCE_CONSTRAINTS.MAX_UNIQUE_KEYS) {
      return `Sequence has ${keyStepCount.size} unique keys, maximum is ${SEQUENCE_CONSTRAINTS.MAX_UNIQUE_KEYS}`;
    }

    for (const [key, count] of keyStepCount) {
      if (count > SEQUENCE_CONSTRAINTS.MAX_STEPS_PER_KEY) {
        return `Key "${key}" used in ${count} steps, maximum is ${SEQUENCE_CONSTRAINTS.MAX_STEPS_PER_KEY} steps per key`;
      }
    }

    return null;
  }

  /**
   * Map our profile key names to RobotJS key names
   */
  private robotJsKeyMap: Record<string, string> = {
    // Numpad keys - RobotJS uses "numpad_X" format
    numpad0: "numpad_0",
    numpad1: "numpad_1",
    numpad2: "numpad_2",
    numpad3: "numpad_3",
    numpad4: "numpad_4",
    numpad5: "numpad_5",
    numpad6: "numpad_6",
    numpad7: "numpad_7",
    numpad8: "numpad_8",
    numpad9: "numpad_9",
    numpad_add: "numpad_+",
    numpad_subtract: "numpad_-",
    numpad_multiply: "numpad_*",
    numpad_decimal: "numpad_.",
    // Escape key
    escape: "escape",
    esc: "escape",
  };

  /**
   * Parse a step key which may include modifiers like "SHIFT+Q" or "ALT+NUMPAD7"
   */
  private parseKey(key: string): { key: string; modifiers: string[] } {
    const parts = key.split("+").map((p) => p.trim());
    const modifiers: string[] = [];
    let base = parts[parts.length - 1];

    // Collect modifiers (all parts except last)
    for (let i = 0; i < parts.length - 1; i++) {
      const m = parts[i].toUpperCase();
      if (m === "SHIFT") modifiers.push("shift");
      else if (m === "ALT") modifiers.push("alt");
      else if (m === "CTRL" || m === "CONTROL") modifiers.push("control");
      else modifiers.push(m.toLowerCase());
    }

    // Normalize base key
    base = base.toUpperCase();
    // Map common patterns (NUMPADx -> numpadx, F6 -> f6)
    if (base.startsWith("NUMPAD")) {
      base = base.replace("NUMPAD", "numpad").toLowerCase();
    } else {
      base = base.toLowerCase();
    }

    // Apply RobotJS key mapping
    if (this.robotJsKeyMap[base]) {
      base = this.robotJsKeyMap[base];
    }

    return { key: base, modifiers };
  }

  /**
   * Buffer tier ranges (inclusive) - base ranges for human randomizer
   * Actual values selected using sophisticated multi-layer randomization
   */
  private bufferRanges: Record<string, [number, number]> = {
    low: [129, 163],
    medium: [229, 263],
    high: [513, 667],
  };

  /**
   * Sleep for specified milliseconds (cancellable - aborts immediately on shutdown)
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => {
      if (this.isShutdown) {
        resolve();
        return;
      }
      const timeoutId = setTimeout(resolve, ms);
      // Store timeout for potential cancellation
      const checkShutdown = setInterval(() => {
        if (this.isShutdown) {
          clearTimeout(timeoutId);
          clearInterval(checkShutdown);
          resolve();
        }
      }, 5); // Check every 5ms for shutdown
      // Also clear interval when timeout completes normally
      setTimeout(() => clearInterval(checkShutdown), ms + 10);
    });
  }

  /**
   * Send a single keypress
   */
  private pressKey(key: string): void {
    // Keep for backward compatibility but prefer explicit key+modifier flow
    const { key: parsedKey, modifiers } = this.parseKey(key);
    // Must pass [] not undefined - Windows RobotJS bug with undefined modifiers
    robot.keyTap(parsedKey, modifiers);
  }

  /**
   * Check if a binding is currently executing
   */
  isBindingExecuting(bindingName: string): boolean {
    return this.isExecuting.get(bindingName) || false;
  }

  /**
   * Get count of currently active executions
   */
  getActiveExecutionCount(): number {
    return this.activeExecutions.size;
  }

  /**
   * Get names of all currently executing bindings
   */
  getActiveBindings(): string[] {
    return Array.from(this.activeExecutions);
  }

  /**
   * Cancel execution for a specific binding
   */
  cancel(bindingName: string): void {
    if (this.isExecuting.get(bindingName)) {
      this.isExecuting.set(bindingName, false);
      this.callback({
        type: "cancelled",
        bindingName,
        timestamp: Date.now(),
      });
    }
  }

  /**
   * Cancel all executions
   */
  cancelAll(): void {
    for (const name of this.activeExecutions) {
      this.cancel(name);
    }
  }

  /**
   * Grant supremacy to a macro - it bypasses traffic control entirely
   * Use for high-priority macros that should never wait
   */
  grantSupremacy(macroName: string): void {
    if (this.trafficController) {
      this.trafficController.grantSupremacy(macroName);
    }
  }

  /**
   * Revoke supremacy from a macro
   */
  revokeSupremacy(macroName: string): void {
    if (this.trafficController) {
      this.trafficController.revokeSupremacy(macroName);
    }
  }

  /**
   * Get list of macros with supremacy
   */
  getSupremacyList(): string[] {
    return this.trafficController?.getSupremacyList() || [];
  }

  /**
   * Destroy the executor - stops all operations and prevents new ones
   */
  destroy(): void {
    this.isShutdown = true;
    // Cancel all bindings first
    this.cancelAll();
    // Cancel any timers
    this.timerManager.cancelAllTimers();
    // Release any held keys immediately
    if (this.heldModifier) {
      try {
        robot.keyToggle(
          this.heldModifier.key,
          "up",
          this.heldModifier.modifiers
        );
      } catch (e) {
        /* ignore */
      }
      this.heldModifier = null;
    }
    // Clear all state
    this.activeExecutions.clear();
    this.isExecuting.clear();
  }

  /**
   * Execute a macro binding's sequence (fire-and-forget)
   * This method launches the execution as a detached promise, allowing
   * multiple different bindings to run simultaneously.
   */
  executeDetached(binding: MacroBinding): void {
    // Check if shutdown in progress
    if (this.isShutdown) return;

    // Check if this specific binding is already executing
    if (this.isExecuting.get(binding.name)) {
      logger.warn(`"${binding.name}" already executing, skipping...`);
      return;
    }

    // Launch as detached promise (don't await - allows concurrency)
    this.executeInternal(binding).catch((error) => {
      if (!this.isShutdown) {
        logger.error(`Detached execution error for "${binding.name}":`, error);
      }
    });
  }

  /**
   * Execute a macro binding's sequence (awaitable)
   * Use this when you need to wait for completion.
   */
  async execute(binding: MacroBinding): Promise<boolean> {
    if (this.isShutdown) return false;
    return this.executeInternal(binding);
  }

  /**
   * Internal execution logic
   */
  private async executeInternal(binding: MacroBinding): Promise<boolean> {
    const { name, sequence } = binding;

    // Check if already executing (per-binding lock)
    if (this.isExecuting.get(name)) {
      logger.warn(`"${name}" already executing, skipping...`);
      return false;
    }

    // Validate sequence
    const validationError = this.validateSequence(sequence);
    if (validationError) {
      this.callback({
        type: "error",
        bindingName: name,
        error: validationError,
        timestamp: Date.now(),
      });
      logger.error(`Validation failed: ${validationError}`);
      return false;
    }

    // Mark as executing
    this.isExecuting.set(name, true);
    this.activeExecutions.add(name);

    this.callback({
      type: "started",
      bindingName: name,
      timestamp: Date.now(),
    });

    const activeCount = this.activeExecutions.size;
    logger.debug(
      `Executing: "${name}" (${sequence.length} steps) [${activeCount} active]`
    );

    try {
      for (let i = 0; i < sequence.length; i++) {
        // Check if cancelled or shutdown
        if (this.isShutdown || !this.isExecuting.get(name)) {
          logger.info(`"${name}" cancelled`);
          return false;
        }

        const step = sequence[i];

        // SCROLL HANDLING: Check if this is a scroll step (must be before parseKey since scroll steps have no key)
        if (step.scrollDirection) {
          const magnitude = step.scrollMagnitude ?? 3;
          // robotjs scrollMouse: positive y = scroll up, negative y = scroll down
          const scrollY =
            step.scrollDirection === "down" ? -magnitude : magnitude;

          logger.debug(`Scroll ${step.scrollDirection}: ${magnitude} units`);
          robot.scrollMouse(0, scrollY);

          // Emit step event for monitoring
          this.callback({
            type: "step",
            bindingName: name,
            step,
            stepIndex: i,
            timestamp: Date.now(),
          });

          // Apply delay for next step using human-like randomization
          const delay = step.bufferTier
            ? getHumanBufferDelay(step.bufferTier)
            : getHumanDelay(step.minDelay || 25, step.maxDelay || 50, "scroll_delay");
          if (delay > 0) await this.sleep(delay);

          continue; // Skip keypress logic
        }

        // Press the key (support modifiers, hold duration, and dual keys)
        const { key: parsedKey, modifiers } = this.parseKey(step.key);

        // DISCORD CONTROL DETECTION: Check if this is a Discord control step
        if (parsedKey === "end" && step.name?.includes("Discord")) {
          const discordController = getDiscordController();
          let handled = false;
          let skipKeyPress = false;

          // Volume control (OS-level)
          if (step.name.includes("Volume: Low")) {
            logger.info("Discord: Setting LOW volume (OS)");
            await discordController.setVolume("low");
            skipKeyPress = true;
            handled = true;
          } else if (step.name.includes("Volume: Medium")) {
            logger.info("Discord: Setting MEDIUM volume (OS)");
            await discordController.setVolume("medium");
            skipKeyPress = true;
            handled = true;
          } else if (step.name.includes("Volume: High")) {
            logger.info("Discord: Setting HIGH volume (OS)");
            await discordController.setVolume("high");
            skipKeyPress = true;
            handled = true;
          }
          // Mic toggle (Discord hotkey)
          else if (step.name.includes("Mic Toggle")) {
            logger.info("Discord: Mic toggle via hotkey (CTRL+SHIFT+M)");
            await discordController.pressDiscordMicToggle();
            // Will press the actual key below
            handled = true;
          }
          // Deafen toggle (Discord hotkey)
          else if (step.name.includes("Deafen")) {
            logger.info("Discord: Deafen toggle via hotkey (CTRL+SHIFT+D)");
            await discordController.pressDiscordDeafenToggle();
            // Will press the actual key below
            handled = true;
          }

          if (handled) {
            // Emit step event for monitoring
            this.callback({
              type: "step",
              bindingName: name,
              step,
              stepIndex: i,
              timestamp: Date.now(),
            });

            // Skip key execution for OS-level volume control only
            if (skipKeyPress) {
              // Skip key execution - Discord OS action executed instead
              continue;
            }
            // For hotkey-based commands, continue to execute the actual keypress below
          }
        }

        // TIMER DETECTION: Check if this is a timer step
        if (parsedKey === "end" && step.name?.includes("Timer placeholder")) {
          // Parse timer duration and message from step.name
          // Format: "Timer placeholder - implement TTS: 'message' after N seconds"
          const durationMatch = step.name.match(/(\d+)\s*seconds?/);
          const messageMatch = step.name.match(/[''](.*?)['']/);

          if (durationMatch && messageMatch) {
            const duration = parseInt(durationMatch[1], 10);
            const message = messageMatch[1];

            // Generate timer ID from binding name or use message as fallback
            const timerId = message.toLowerCase().replace(/\s+/g, "_");

            logger.debug(
              `Timer detected: ${timerId} (${duration}s) ‚Üí "${message}"`
            );

            // Start timer instead of pressing END key
            this.timerManager.startTimer(timerId, duration, message);

            // Emit step event for monitoring
            this.callback({
              type: "step",
              bindingName: name,
              step,
              stepIndex: i,
              timestamp: Date.now(),
            });

            // Skip key execution - timer started instead
            continue;
          } else {
            logger.warn(
              `Timer step detected but couldn't parse: "${step.name}"`
            );
            // Fall through to normal key execution
          }
        }

        // ENDURE PAIN TIMER: Automatically start 16s "drop" timer when SHIFT+, is pressed
        if (
          step.key.toUpperCase() === "SHIFT+," ||
          step.key.toUpperCase() === "SHIFT + ,"
        ) {
          logger.debug(
            'Endure Pain detected (SHIFT+,) - starting 16s "drop" timer'
          );
          this.timerManager.startTimer("drop", 16, "drop");
        }

        // Traffic control for conundrum keys: wait if necessary
        if (this.compiledProfile && this.trafficController) {
          const needsTraffic = isConundrumKey(step.key, this.compiledProfile);
          if (needsTraffic) {
            await this.trafficController.requestCrossing(step.key, name);
          }
        }

        // Determine key down duration using human-like randomization
        const kd = step.keyDownDuration || [23, 38];
        const keyDownMs = getHumanKeyDownDuration(kd[0], kd[1]);

        // Check for dual key configuration
        const hasDualKey = step.dualKey !== undefined;
        let dualParsedKey: { key: string; modifiers: string[] } | null = null;
        let dualKeyDownMs = 0;

        if (hasDualKey) {
          // Parse dual key
          dualParsedKey = this.parseKey(step.dualKey!);

          // Determine dual key hold duration using human-like randomization
          const dualKd = step.dualKeyDownDuration || kd;
          dualKeyDownMs = getHumanKeyDownDuration(dualKd[0], dualKd[1]);
        }

        // PRIMARY KEY DOWN
        try {
          // Must pass modifiers array (even if empty) - Windows RobotJS bug with undefined
          robot.keyToggle(parsedKey, "down", modifiers);
        } catch (err) {
          // Fallback to keyTap if keyToggle unsupported for this key
          this.pressKey(step.key);
        }

        // Emergency key release on shutdown
        if (this.isShutdown) {
          try {
            robot.keyToggle(parsedKey, "up", modifiers);
          } catch (e) {
            /* ignore */
          }
          return false;
        }

        this.callback({
          type: "step",
          bindingName: name,
          step,
          stepIndex: i,
          timestamp: Date.now(),
        });

        if (hasDualKey) {
          // DUAL KEY MODE: Press second key after offset
          // Use human-like randomization for offset (4-10ms range instead of fixed 6)
          const offsetMs = step.dualKeyOffsetMs ?? getHumanDualKeyOffset();

          logger.debug(
            `[${i + 1}/${sequence.length}] Pressed "${step.key}" + "${
              step.dualKey
            }" (dual) primary=${keyDownMs}ms, dual=${dualKeyDownMs}ms, offset=${offsetMs}ms`
          );

          // Wait for offset before pressing dual key
          await this.sleep(offsetMs);

          // Emergency release primary on shutdown
          if (this.isShutdown) {
            try {
              robot.keyToggle(parsedKey, "up", modifiers);
            } catch (e) {
              /* ignore */
            }
            return false;
          }

          // DUAL KEY DOWN
          try {
            robot.keyToggle(
              dualParsedKey!.key,
              "down",
              dualParsedKey!.modifiers.length === 0
                ? undefined
                : dualParsedKey!.modifiers
            );
          } catch (err) {
            // Fallback to keyTap if keyToggle unsupported
            this.pressKey(step.dualKey!);
          }

          // Emergency release both on shutdown
          if (this.isShutdown) {
            try {
              robot.keyToggle(parsedKey, "up", modifiers);
            } catch (e) {
              /* ignore */
            }
            try {
              robot.keyToggle(
                dualParsedKey!.key,
                "up",
                dualParsedKey!.modifiers.length === 0
                  ? undefined
                  : dualParsedKey!.modifiers
              );
            } catch (e) {
              /* ignore */
            }
            return false;
          }

          // Hold primary key for remaining duration (already held for offsetMs)
          const primaryRemainingMs = Math.max(0, keyDownMs - offsetMs);
          await this.sleep(primaryRemainingMs);

          // Emergency release both on shutdown
          if (this.isShutdown) {
            try {
              robot.keyToggle(parsedKey, "up", modifiers);
            } catch (e) {
              /* ignore */
            }
            try {
              robot.keyToggle(
                dualParsedKey!.key,
                "up",
                dualParsedKey!.modifiers.length === 0
                  ? undefined
                  : dualParsedKey!.modifiers
              );
            } catch (e) {
              /* ignore */
            }
            return false;
          }

          // PRIMARY KEY UP (releases first)
          try {
            // Must pass modifiers array (even if empty) - Windows RobotJS bug with undefined
            robot.keyToggle(parsedKey, "up", modifiers);
          } catch (err) {
            // If keyToggle failed, nothing else to do
          }

          // Hold dual key for its full duration (or remaining if longer than primary)
          const dualRemainingMs = Math.max(
            0,
            dualKeyDownMs - (offsetMs + primaryRemainingMs)
          );
          if (dualRemainingMs > 0) {
            await this.sleep(dualRemainingMs);
            // Emergency release dual on shutdown
            if (this.isShutdown) {
              try {
                robot.keyToggle(
                  dualParsedKey!.key,
                  "up",
                  dualParsedKey!.modifiers.length === 0
                    ? undefined
                    : dualParsedKey!.modifiers
                );
              } catch (e) {
                /* ignore */
              }
              return false;
            }
          }

          // DUAL KEY UP (releases second)
          try {
            robot.keyToggle(
              dualParsedKey!.key,
              "up",
              dualParsedKey!.modifiers.length === 0
                ? undefined
                : dualParsedKey!.modifiers
            );
          } catch (err) {
            // If keyToggle failed, nothing else to do
          }
        } else {
          // SINGLE KEY MODE: Normal behavior
          logger.debug(
            `[${i + 1}/${sequence.length}] Pressed "${
              step.key
            }" held ${keyDownMs}ms`
          );

          // Hold duration
          await this.sleep(keyDownMs);

          // Emergency release on shutdown
          if (this.isShutdown) {
            try {
              robot.keyToggle(parsedKey, "up", modifiers);
            } catch (e) {
              /* ignore */
            }
            return false;
          }

          // Check if this step should hold through next step
          if (step.holdThroughNext) {
            // Store held modifier info for release during next step's buffer
            this.heldModifier = {
              key: parsedKey,
              modifiers,
              releaseDelayMin: step.releaseDelayMin ?? 7,
              releaseDelayMax: step.releaseDelayMax ?? 18,
            };
            logger.debug(
              `Holding "${step.key}" through next step (will release after ${this.heldModifier.releaseDelayMin}-${this.heldModifier.releaseDelayMax}ms of next buffer)`
            );
            // Skip the normal release - key stays down
          } else {
            // PRIMARY KEY UP (normal release)
            try {
              // Must pass modifiers array (even if empty) - Windows RobotJS bug with undefined
              robot.keyToggle(parsedKey, "up", modifiers);
            } catch (err) {
              // If keyToggle failed, nothing else to do
            }
          }
        }

        // Release traffic control if it was acquired
        if (this.compiledProfile && this.trafficController) {
          const needsTraffic = isConundrumKey(step.key, this.compiledProfile);
          if (needsTraffic) {
            this.trafficController.releaseCrossing(step.key);
          }
        }

        // Determine buffer delay after this key press
        const isLastStep = i === sequence.length - 1;

        if (!isLastStep) {
          let delay: number;

          if (step.bufferTier) {
            // Use human-like buffer delay
            delay = getHumanBufferDelay(step.bufferTier);
          } else {
            // Fall back to human-like delay with legacy min/max
            delay = getHumanDelay(step.minDelay, step.maxDelay, "legacy_buffer");
          }

          this.callback({
            type: "step",
            bindingName: name,
            step,
            stepIndex: i,
            delay,
            timestamp: Date.now(),
          });

          console.log(`     ‚è±Ô∏è  Waiting ${delay}ms...`);

          // ECHO HITS: Rapid repeat keypresses during buffer phase
          if (
            step.echoHits &&
            step.echoHits.count > 0 &&
            step.echoHits.windowMs > 0
          ) {
            const echoCount = step.echoHits.count;
            const echoWindowMs = step.echoHits.windowMs;
            const echoIntervalMs = Math.floor(echoWindowMs / (echoCount + 1));

            logger.debug(
              `Echo hits: ${echoCount} repeats of "${step.key}" within ${echoWindowMs}ms (interval ~${echoIntervalMs}ms)`
            );

            for (let e = 0; e < echoCount; e++) {
              // Wait for echo interval
              await this.sleep(echoIntervalMs);

              if (this.isShutdown) return false;

              // Quick tap with human-like hold duration for echo
              const echoHoldMs = getHumanEchoHitDuration();
              try {
                robot.keyToggle(parsedKey, "down", modifiers);
                await this.sleep(echoHoldMs);
                if (this.isShutdown) {
                  try {
                    robot.keyToggle(parsedKey, "up", modifiers);
                  } catch (e) {}
                  return false;
                }
                robot.keyToggle(parsedKey, "up", modifiers);
              } catch (err) {
                // Fallback to keyTap
                this.pressKey(step.key);
              }

              logger.debug(
                `  Echo ${e + 1}/${echoCount}: "${
                  step.key
                }" held ${echoHoldMs}ms`
              );
            }

            // Remaining buffer time after echo hits
            const echoTimeUsed = echoIntervalMs * echoCount;
            const remainingBufferAfterEcho = Math.max(0, delay - echoTimeUsed);

            // Handle held modifier release if applicable
            if (this.heldModifier && i > 0) {
              const releaseDelay = getHumanReleaseDelay(
                this.heldModifier.releaseDelayMin,
                this.heldModifier.releaseDelayMax
              );

              if (remainingBufferAfterEcho >= releaseDelay) {
                await this.sleep(releaseDelay);
                logger.debug(
                  `Releasing held modifier after ${releaseDelay}ms of remaining buffer`
                );
                try {
                  robot.keyToggle(
                    this.heldModifier.key,
                    "up",
                    this.heldModifier.modifiers.length === 0
                      ? undefined
                      : this.heldModifier.modifiers
                  );
                } catch (err) {
                  /* ignore */
                }
                this.heldModifier = null;

                const finalRemaining = remainingBufferAfterEcho - releaseDelay;
                if (finalRemaining > 0) {
                  await this.sleep(finalRemaining);
                }
              } else {
                await this.sleep(remainingBufferAfterEcho);
              }
            } else if (remainingBufferAfterEcho > 0) {
              await this.sleep(remainingBufferAfterEcho);
            }
          }
          // If there's a held modifier from the previous step, release it partway through this buffer
          else if (this.heldModifier && i > 0) {
            const releaseDelay = getHumanReleaseDelay(
              this.heldModifier.releaseDelayMin,
              this.heldModifier.releaseDelayMax
            );

            // Wait for the release delay first
            await this.sleep(releaseDelay);

            // Release the held modifier
            logger.debug(
              `Releasing held modifier after ${releaseDelay}ms of buffer`
            );
            try {
              robot.keyToggle(
                this.heldModifier.key,
                "up",
                this.heldModifier.modifiers.length === 0
                  ? undefined
                  : this.heldModifier.modifiers
              );
            } catch (err) {
              // If keyToggle failed, nothing else to do
            }

            // Clear held modifier
            this.heldModifier = null;

            // Wait for the remaining buffer time
            const remainingDelay = delay - releaseDelay;
            if (remainingDelay > 0) {
              await this.sleep(remainingDelay);
            }
          } else {
            // No held modifier, just wait the full buffer
            await this.sleep(delay);
          }
        } else if (this.heldModifier) {
          // Last step and there's a held modifier - release it after its configured delay
          const releaseDelay = getHumanReleaseDelay(
            this.heldModifier.releaseDelayMin,
            this.heldModifier.releaseDelayMax
          );
          await this.sleep(releaseDelay);

          logger.debug(
            `Releasing held modifier after ${releaseDelay}ms (last step)`
          );
          try {
            robot.keyToggle(
              this.heldModifier.key,
              "up",
              this.heldModifier.modifiers.length === 0
                ? undefined
                : this.heldModifier.modifiers
            );
          } catch (err) {
            // If keyToggle failed, nothing else to do
          }
          this.heldModifier = null;
        }
      }

      this.callback({
        type: "completed",
        bindingName: name,
        timestamp: Date.now(),
      });

      logger.info(`"${name}" complete`);
      return true;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";

      this.callback({
        type: "error",
        bindingName: name,
        error: errorMsg,
        timestamp: Date.now(),
      });

      logger.error(`"${name}" failed: ${errorMsg}`);
      return false;
    } finally {
      // Cleanup: release any held modifier if sequence ends prematurely
      if (this.heldModifier) {
        logger.debug("Cleaning up held modifier due to sequence end/error");
        try {
          robot.keyToggle(
            this.heldModifier.key,
            "up",
            this.heldModifier.modifiers.length === 0
              ? undefined
              : this.heldModifier.modifiers
          );
        } catch (err) {
          // Ignore cleanup errors
        }
        this.heldModifier = null;
      }

      this.isExecuting.set(name, false);
      this.activeExecutions.delete(name);
    }
  }

  /**
   * Test execution without actually sending keys (dry run)
   */
  async dryRun(binding: MacroBinding): Promise<void> {
    const { name, sequence } = binding;

    const validationError = this.validateSequence(sequence);
    if (validationError) {
      console.error(`‚ùå Validation failed: ${validationError}`);
      return;
    }

    console.log(`\nüß™ DRY RUN: "${name}" (${sequence.length} steps)`);

    const keyCount: Map<string, number> = new Map();
    for (const step of sequence) {
      keyCount.set(step.key, (keyCount.get(step.key) || 0) + 1);
    }

    logger.info(
      `Unique keys: ${keyCount.size}/${SEQUENCE_CONSTRAINTS.MAX_UNIQUE_KEYS}`
    );
    logger.info(`Total key presses: ${sequence.length}`);
    for (const [key, count] of keyCount) {
      logger.info(`- "${key}": ${count}x`);
    }

    let totalMinTime = 0;
    let totalMaxTime = 0;

    for (let i = 0; i < sequence.length; i++) {
      const step = sequence[i];
      logger.info(
        `[${i + 1}] "${step.key}" ‚Üí wait ${step.minDelay}-${step.maxDelay}ms`
      );

      const isLastStep = i === sequence.length - 1;
      if (!isLastStep) {
        totalMinTime += step.minDelay;
        totalMaxTime += step.maxDelay;
      }
    }

    console.log(`   ‚è±Ô∏è  Total time: ${totalMinTime}-${totalMaxTime}ms\n`);
  }

  /**
   * Shutdown executor and clean up resources
   */
  shutdown(): void {
    logger.info("Shutting down SequenceExecutor...");
    this.cancelAll();
    this.timerManager.shutdown();
  }
}